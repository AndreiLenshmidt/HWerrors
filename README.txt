1. Итоговая работа написана на языке JavaScript. В качестве среды для разработки 
использовался блокнот и браузер (Chrome) для отладки. Для проверки рекомендую 
использовать браузер => инструменты разработчика, либо любую удобную для вас
среду разработки.

2. Все работает так: 

Внутри цикла запрашиваются данные у пользователя в виде строки через функцию
inputUserInfo()=> возвращает строку, далее они парсятся через parseUserInfo()=> возвращает 
объект, и в конце сохраняются внутри let files = new Map() по ключу ФИО в формате JSON
с выводом результата в консоль. После сохранения данных можно добавить новые данные, 
либо завершить выполнение скрипта.

FileReader в JS умеет только читать данные из файла, запись файла на ПК ему недоступна. 
Часть итоговой работы с записью-чтением файлов реализовать на чистом JS невозможно,
и в качестве альтернативы реализована запись в Мар.

Конструкция try ... catch() в JS отличается от аналогичной в Java тем, что нет реализации 
try(параметр) и множественного catch(). Разные типы ошибок фильтруются через if-else, либо
с помошью вложенного  try ... catch().

3. Подробнее про скрипт.

3. 1 При запросе данных возможны следующие действия:
- Если пользователь ввел непустую строку с корректными или некорректными данными, то 
они парсятся через функцию parseUserInfo();
- Если введена пустая строка, то будет ошибка 
ReferenceError("You entered an empty string, please try again!"), всплывающее окно
предложит повторить ввод, кнопка Ок-повтор ввода, кнопка ОТМЕНА-завершает выполнение
скрипта;
- Если пользователь сразу нажимает кнопку ОТМЕНА при запросе ввода выполнение скрипта
также завершается.

inputUserInfo() возвращает вспомогательную функцию deleteStartEndSpaces(UserInformation),
которая удалит все пробелы сначала и с конца строки, и вернет эту же строку без пробелов.

3.2 Полученная строка со всеми данными парсится с помошью parseUserInfo(). Порядок ввода 
данных неважен, можно ввести сначада Телефон, ДР, а затем ФИО. Все будет работать даже если
ввести Фамилию, ДР, Имя, телефон, Отчество. Есть только одно ограничение, порядок ФИО должен
сохранятся т.е. Фамилия, Имя, Отчество. 

parseUserInfo() работает так: 
- принятая строка преобразуется в массив через .split(" "), 
- вспомогательная функция deleteEmptyItems(Array) удаляет все пустые элементы массива, которые
могут получится если между словами в строке будет более одного пробела;
- через for ... of  отлавливается телефон и дата рождения, а все остальное добавляется в массив ФИО;
- через if-else (вместо множественного catch()) данные проверяются на ошибки: нет телефона, нет 
даты рождения, дважды введен телефон или дата рождения, некорректное ФИО (должны быть 
минимум фамилия и имя), также не менее 4 и не более 5 слов в строке(ФИО, тел, ДР 
либо ФИ, тел, ДР если нет отчества);
- если данные корректны, возвращается объект new User(fullName, phone, dateOfBirth), если данные 
не корректны то будет пробшена одна из ошибок и функция вернет underfind.

3.3. Запись в Map. Внутри функция saveUser (map, user) никак не обрабатывает ошибки т.к. возможны
две ситуации либо она принимает корректные данные либо user = underfind. Для второго случая 
необходим повторный ввод данных, поэтому saveUser (map, user) находится внутри  try ... catch(), 
ошибка выводится в консоль, а цикл while начинает итерацию сначала, с запроса данных.

Корректные данные по ключу ФИО записываются в Map, если добавляется User ФИО котрого уже есть
в Map, то под общим ключом записывается массив из 2-х и более Users. По аналогии ключ это имя файла, 
и в одном "файле" может быть несколько Users с одинаковыми ФИО.









